"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.amqpConnect=amqpConnect;exports.amqpDisconnect=amqpDisconnect;exports.channelAssertExchange=channelAssertExchange;exports.channelAssertQueue=channelAssertQueue;exports.channelBindQueue=channelBindQueue;exports.channelConsume=channelConsume;exports.channelPublish=channelPublish;exports.connectionCreateChannel=connectionCreateChannel;exports.consume=consume;exports.decode=decode;exports.encode=encode;exports.fromJson=void 0;exports.getContent=getContent;exports.getExchange=void 0;exports.getFields=getFields;exports.getPort=exports.getPassword=exports.getHostname=void 0;exports.getProperties=getProperties;exports.getVirtualHost=exports.getUsername=exports.getRoutingKey=exports.getQueue=void 0;exports.publish=publish;exports.toString=exports.toJson=exports.toBuffer=void 0;exports.transform=transform;var _debug=_interopRequireDefault(require("debug"));var _amqplib=_interopRequireDefault(require("amqplib"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const log=(0,_debug.default)('@sequencemedia');const info=(0,_debug.default)('@sequencemedia/rabbit-mq');log('`@sequencemedia/rabbit-mq` is awake');const CLOSE=60*1000;let CONNECTION=null;const CONNECTIONS=new Map();const getUsername=({username='guest'})=>username;exports.getUsername=getUsername;const getPassword=({password='guest'})=>password;exports.getPassword=getPassword;const getHostname=({hostname='localhost'})=>hostname;exports.getHostname=getHostname;const getPort=({port=5672})=>port;exports.getPort=getPort;const getVirtualHost=({virtualHost=''})=>virtualHost;exports.getVirtualHost=getVirtualHost;const getExchange=({exchange})=>exchange;exports.getExchange=getExchange;const getQueue=({queueName})=>queueName;exports.getQueue=getQueue;const getRoutingKey=({routingKey})=>routingKey;exports.getRoutingKey=getRoutingKey;const toJson=value=>JSON.stringify(value);exports.toJson=toJson;const fromJson=value=>JSON.parse(value);exports.fromJson=fromJson;const toBuffer=string=>Buffer.from(string,'utf8');exports.toBuffer=toBuffer;const toString=buffer=>buffer.toString('utf8');exports.toString=toString;function getFields({fields}){info('getFields');if(fields)return fields;}function getProperties({properties}){info('getProperties');if(properties)return properties;}function getContent({content}){info('getContent');if(content)return content;}function encode(content){info('encode');return toBuffer(toJson(content));}function decode(content){info('decode');return fromJson(toString(content));}function transform(params){info('transform');const username=getUsername(params);const password=getPassword(params);const hostname=getHostname(params);const port=getPort(params);const virtualHost=getVirtualHost(params);return`amqp://${username}:${password}@${hostname}:${port}/${virtualHost}`;}async function amqpConnect(params){info('amqpConnect');const connection=CONNECTION||(CONNECTION=await _amqplib.default.connect(transform(params)));return{...params,connection};}async function amqpDisconnect({connection,...params}){info('amqpDisconnect');if(CONNECTIONS.has(connection))clearTimeout(CONNECTIONS.get(connection));CONNECTIONS.set(connection,setTimeout(async()=>{try{if(connection===CONNECTION)CONNECTION=null;CONNECTIONS.delete(connection);await connection.close();}catch(e){info(e);}},CLOSE));return{...params,connection};}async function connectionCreateChannel({connection,...params}){info('connectionCreateChannel');const channel=await connection.createChannel();return{...params,connection,channel};}async function channelAssertExchange({channel,...params}){info('channelAssertExchange');const EXCHANGE=getExchange(params);const{exchange}=await channel.assertExchange(EXCHANGE,'topic',{durable:true});info(EXCHANGE,exchange);return{...params,channel,exchange};}async function channelAssertQueue({channel,...params}){info('channelAssertQueue');const QUEUE=getQueue(params);const{queue}=await channel.assertQueue(QUEUE,{durable:true});info(QUEUE,queue);return{...params,channel,queue};}async function channelBindQueue({channel,queue,exchange,...params}){info('channelBindQueue');const ROUTINGKEY=getRoutingKey(params);await channel.bindQueue(queue,exchange,ROUTINGKEY);info(queue,exchange,ROUTINGKEY);return{...params,channel,queue,exchange};}async function channelPublish({channel,queue,...params}){info('channelPublish');const CONTENT=getContent(params);channel.sendToQueue(queue,encode(CONTENT));return{...params,queue};}async function channelConsume({channel,queue,handler,...params}){info('channelConsume');await channel.consume(queue,async function consumer(message){info('consumer');const{fields:{exchange,routingKey}={}}=message;channel.ack(message);const CONTENT=getContent(message);info({exchange,routingKey});return handler({...message,content:decode(CONTENT)});});return{...params,channel,queue};}const getErrorMessage=({message='No error message defined'})=>message;function handlePublishError(e){log(`Publish failed with message "${getErrorMessage(e)}"`);throw e;}function handleConsumeError(e){log(`Consume failed with message "${getErrorMessage(e)}"`);throw e;}async function publish(params={},content={},routingKey=getRoutingKey(params)){info('publish');return await amqpConnect({...params,content,routingKey}).then(connectionCreateChannel).then(channelAssertExchange).then(channelAssertQueue).then(channelPublish).then(amqpDisconnect).catch(handlePublishError);}async function consume(params={},handler=content=>{log(content);},routingKey=getRoutingKey(params)){info('consume');return await amqpConnect({...params,handler,routingKey}).then(connectionCreateChannel).then(channelAssertExchange).then(channelAssertQueue).then(channelBindQueue).then(channelConsume).catch(handleConsumeError);}process.on('exit',async()=>{console.log('before exit ...');console.log('EXIT');});