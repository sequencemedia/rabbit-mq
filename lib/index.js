"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.amqpConnect=amqpConnect;exports.amqpDisconnect=amqpDisconnect;exports.channelAssertExchange=channelAssertExchange;exports.channelAssertQueue=channelAssertQueue;exports.channelBindQueue=channelBindQueue;exports.channelClose=channelClose;exports.channelConsume=channelConsume;exports.channelPublish=channelPublish;exports.channelQueue=channelQueue;exports.connectionCreateChannel=connectionCreateChannel;exports.consume=consume;exports.decode=decode;exports.encode=encode;exports.fromJson=void 0;exports.getContent=getContent;exports.getExchange=void 0;exports.getFields=getFields;exports.getPort=exports.getPassword=exports.getHostname=void 0;exports.getProperties=getProperties;exports.getVirtualHost=exports.getUsername=exports.getRoutingKey=exports.getQueue=void 0;exports.publish=publish;exports.queue=queue;exports.toString=exports.toJson=exports.toBuffer=void 0;exports.transform=transform;var _debug=_interopRequireDefault(require("debug"));var _amqplib=_interopRequireDefault(require("amqplib"));var _args=_interopRequireDefault(require("./args"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const log=(0,_debug.default)('@sequencemedia/rabbit-mq');log('`@sequencemedia/rabbit-mq` is awake');const DURATION=1000;const LIMIT=500;const CLOSE=60*1000;let CONNECTION=null;const CONNECTIONS=new Map();const HANDLER=content=>{log(content);};if((0,_args.default)())setInterval(()=>log({connections:CONNECTIONS.size,connection:Boolean(CONNECTION)}),CLOSE/2);function sleepFor(duration=DURATION){return new Promise(resolve=>{setTimeout(resolve,duration);});}const getUsername=({username='guest'})=>username;exports.getUsername=getUsername;const getPassword=({password='guest'})=>password;exports.getPassword=getPassword;const getHostname=({hostname='localhost'})=>hostname;exports.getHostname=getHostname;const getPort=({port=5672})=>port;exports.getPort=getPort;const getVirtualHost=({virtualHost=''})=>virtualHost;exports.getVirtualHost=getVirtualHost;const getExchange=({exchange})=>exchange;exports.getExchange=getExchange;const getQueue=({queueName})=>queueName;exports.getQueue=getQueue;const getRoutingKey=({routingKey})=>routingKey;exports.getRoutingKey=getRoutingKey;const toJson=value=>JSON.stringify(value);exports.toJson=toJson;const fromJson=value=>JSON.parse(value);exports.fromJson=fromJson;const toBuffer=string=>Buffer.from(string,'utf8');exports.toBuffer=toBuffer;const toString=buffer=>buffer.toString('utf8');exports.toString=toString;function getFields({fields}){log('getFields');if(fields)return fields;}function getProperties({properties}){log('getProperties');if(properties)return properties;}function getContent({content}){log('getContent');if(content)return content;}function encode(content){log('encode');return toBuffer(toJson(content));}function decode(content){log('decode');return fromJson(toString(content));}function transform(params){log('transform');const username=getUsername(params);const password=getPassword(params);const hostname=getHostname(params);const port=getPort(params);const virtualHost=getVirtualHost(params);return`amqp://${username}:${password}@${hostname}:${port}/${virtualHost}`;}async function amqpConnect(params,n=0){log('amqpConnect');try{const connection=CONNECTION??(CONNECTION=await _amqplib.default.connect(transform(params)));return{...params,connection};}catch(e){const{code,message}=e;if(code==='ECONNREFUSED'||message.startsWith('Handshake terminated by server')){if(n!==LIMIT){await sleepFor(DURATION);return await amqpConnect(params,n+1);}throw new Error(`Limit reached for "${transform(params)}"`);}throw e;}}async function amqpDisconnect({connection,...params}){log('amqpDisconnect');if(CONNECTIONS.has(connection))clearTimeout(CONNECTIONS.get(connection));CONNECTIONS.set(connection,setTimeout(async function timeout(){log('timeout');try{if(connection===CONNECTION)CONNECTION=null;CONNECTIONS.delete(connection);await connection.close();}catch(e){handleDisconnectError(e);}},CLOSE));}async function connectionCreateChannel({connection,...params}){log('connectionCreateChannel');const channel=await connection.createChannel();return{...params,connection,channel};}async function channelAssertExchange({channel,...params}){log('channelAssertExchange');const EXCHANGE=getExchange(params);const{exchange}=await channel.assertExchange(EXCHANGE,'topic',{durable:true});return{...params,channel,exchange};}async function channelAssertQueue({channel,...params}){log('channelAssertQueue');const QUEUE=getQueue(params);const{queue}=await channel.assertQueue(QUEUE,{durable:true});return{...params,channel,queue};}async function channelBindQueue({channel,queue,exchange,...params}){log('channelBindQueue');const ROUTINGKEY=getRoutingKey(params);await channel.bindQueue(queue,exchange,ROUTINGKEY);return{...params,channel,queue,exchange};}async function channelPublish({channel,exchange,...params},n=0){log('channelPublish');try{const ROUTINGKEY=getRoutingKey(params);const CONTENT=getContent(params);channel.publish(exchange,ROUTINGKEY,encode(CONTENT));return{...params,channel,exchange};}catch({code,message}){log({...(code?{code}:{}),message});if(n!==LIMIT){await sleepFor(DURATION);return await channelPublish({...params,channel,exchange},n+1);}throw new Error(`Limit reached for channel "${channel}" and exchange "${exchange}"`);}}async function channelQueue({channel,queue,...params}){log('channelQueue');const CONTENT=getContent(params);channel.sendToQueue(queue,encode(CONTENT));return{...params,channel,queue};}async function channelClose({channel,...params}){log('channelClose');await channel.close();return{...params};}async function channelConsume({channel,queue,handler,...params},n=0){log('channelConsume');try{return await channel.consume(queue,async function consumer(message){log('consumer');channel.ack(message);const CONTENT=getContent(message);return await handler({...message,content:decode(CONTENT)});});}catch({code,message}){log({...(code?{code}:{}),message});if(n!==LIMIT){await sleepFor(DURATION);return await channelConsume({...params,channel,queue,handler},n+1);}throw new Error(`Limit reached for channel "${channel}" and queue "${queue}"`);}}const getErrorMessage=({message='N/A'})=>message;function handleDisconnectError(e){log(`Disconnect failed with message "${getErrorMessage(e)}"`);}function handlePublishError(e){log(`Publish failed with message "${getErrorMessage(e)}"`);throw e;}function handleQueueError(e){log(`Queue failed with message "${getErrorMessage(e)}"`);throw e;}function handleConsumeError(e){log(`Consume failed with message "${getErrorMessage(e)}"`);throw e;}async function publish(params={},content={},routingKey=getRoutingKey(params)){log('publish');return await amqpConnect({...params,content,routingKey}).then(connectionCreateChannel).then(channelAssertExchange).then(channelAssertQueue).then(channelPublish).then(channelClose).then(amqpDisconnect).catch(handlePublishError);}async function queue(params={},content={},routingKey=getRoutingKey(params)){log('queue');return await amqpConnect({...params,content,routingKey}).then(connectionCreateChannel).then(channelAssertExchange).then(channelAssertQueue).then(channelQueue).then(channelClose).then(amqpDisconnect).catch(handleQueueError);}async function consume(params={},handler=HANDLER,routingKey=getRoutingKey(params)){log('consume');return await amqpConnect({...params,handler,routingKey}).then(connectionCreateChannel).then(channelAssertExchange).then(channelAssertQueue).then(channelBindQueue).then(channelConsume).catch(handleConsumeError);}